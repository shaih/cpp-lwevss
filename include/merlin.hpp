#ifndef _MERLIN_H_
#define _MERLIN_H_
/* merlin.hpp - Wrappers around Merlin context
 * 
 * Copyright (C) 2021, LWE-PVSS
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 **/
#include "scalar25519.hpp"
#include "point25519.hpp"
#include "constraints.hpp"
extern "C"
{
#include "libmerlin/merlin.h" // "C" implementation of Melin Transcripts
}

// We use Merlin transcripts https://merlin.cool to generate the challenges
// and blinding factors for the Fiat-Shamir proofs. The current state of a
// Merlin context includes a hash of all the transcript so far, the next
// challenge is computed as a hash of the current state, and a blinding
// factor is generated by hashing the current state, secrets held by the
// prover, and 32 bytes of fresh randomness.
//
// FIXME: We rely on the "one C file implementation" of Merlin from
// https://github.com/hdevalence/libmerlin (4bf6228). This implementation
// is buggy, for example we had to change FLAG_M to FLAG_C in line 178 of
// merlin.c for it to work. Production code will have to fix that Merlin
// implementation.

namespace Merlin {
inline void bytesFromInt(unsigned char *buf, size_t num) { // simple serialization, big endian
    for (int i=0; i< sizeof(size_t); i++) {
        buf[i] = (unsigned char) num & 0xff;
        num >>= 8;
    }
}
inline size_t intFromBytes(unsigned char *buf) {
    int num = 0;
    for (int i=0; i< sizeof(size_t); i++) {
        num += ((size_t)buf[i]) << (8*i);
    }
    return num;
}

struct MerlinBPctx { // A wrapper object around the "C" merlin_transcript
    merlin_transcript mctx;
    explicit MerlinBPctx(const std::string& label) {
        merlin_transcript_init(&mctx, (const unsigned char *)label.data(), label.size());
    }

    // Add a labeled scalar to the current state
    void processScalar(const std::string& label, const CRV25519::Scalar& s) { 
        merlin_transcript_commit_bytes(&mctx,
            (const unsigned char *)label.data(), label.size(),
            s.dataBytes(), crypto_core_ed25519_SCALARBYTES);
    }

    // Add a labeled group element to the current state
    void processPoint(const std::string& label, const CRV25519::Point& p) { 
        merlin_transcript_commit_bytes(&mctx,
            (const unsigned char *)label.data(), label.size(),
            p.dataBytes(), crypto_core_ed25519_BYTES);
    }

    // Add a labeled set of contraints to the current state
    void processConstraint(const std::string& label, const DLPROOFS::LinConstraint& c) {
        unsigned char buf[sizeof(size_t)];
        merlin_transcript_commit_bytes(&mctx,
            (const unsigned char *)label.data(), label.size(), buf, 0);
        for (auto& x : c.terms) { // x is a pair (idx, scalar)
            int idx = x.first;
            const CRV25519::Scalar& s = x.second;
            bytesFromInt(buf, idx);
            merlin_transcript_commit_bytes(&mctx,
                buf, sizeof(buf), s.dataBytes(), crypto_core_ed25519_SCALARBYTES);
        }
        processScalar(std::string("b"), c.equalsTo);
    }
    // Add a labeled set of contraints to the current state
    void processConstraint(const std::string& label, const DLPROOFS::QuadConstraint& c) {
        size_t n = c.indexes.size();
        unsigned char buf[sizeof(size_t)*n];
        merlin_transcript_commit_bytes(&mctx,
            (const unsigned char *)label.data(), label.size(), buf, 0);
        // Get byte representation of all the indexes
        size_t i=0;
        for (size_t idx : c.indexes) {
            bytesFromInt(buf+(i*sizeof(size_t)), idx);
            i++;
        }
        merlin_transcript_commit_bytes(&mctx,
                (unsigned char*)"indexes", 7, buf, sizeof(size_t)*n);
        processScalar(std::string("b"), c.equalsTo);
    }

    // a new scalar challenge, computed as hash of current state
    CRV25519::Scalar newChallenge(const std::string& label) {
        unsigned char buf[crypto_core_ed25519_NONREDUCEDSCALARBYTES];
        merlin_transcript_challenge_bytes(&mctx,
            (const unsigned char*)label.data(),label.size(),buf,sizeof(buf));
        CRV25519::Scalar s;
        crypto_core_ed25519_scalar_reduce(s.bytes, buf);
        return s;
    }

    // a new random group element, computed as hash of current state
    CRV25519::Point newGenerator(const std::string& label) {
        unsigned char buf[crypto_core_ed25519_UNIFORMBYTES];
        merlin_transcript_challenge_bytes(&mctx,
            (const unsigned char*)label.data(),label.size(),buf,sizeof(buf));
        CRV25519::Point p;
        crypto_core_ed25519_from_uniform(p.bytes, buf);
        return p;
    }

    // choose two new blinding factors, computed as a hash of the
    // current state, the witness(es), and some new randomness
    std::pair<CRV25519::Scalar,CRV25519::Scalar>
    newBlindingFactors(const std::string& label, size_t n,
            const CRV25519::Scalar* xes, const CRV25519::Scalar* ys=nullptr) {
        merlin_rng mrng;
        merlin_rng_init(&mrng, &mctx);

        // a large enough buffer
        unsigned char buf[2*crypto_core_ed25519_NONREDUCEDSCALARBYTES];

        if (n>0) {
            merlin_rng_commit_witness_bytes(&mrng, (const uint8_t*)label.data(), label.size(),
                        (const uint8_t*) xes[0].dataBytes(), crypto_core_ed25519_SCALARBYTES);
            for (size_t i=1; i<n; i++) {
                bytesFromInt(buf, i);
                merlin_rng_commit_witness_bytes(&mrng, buf, sizeof(size_t),
                        (const uint8_t*) xes[i].dataBytes(), crypto_core_ed25519_SCALARBYTES);
            }
            if (ys != nullptr) for (size_t i=0; i<n; i++) {
                bytesFromInt(buf, i+n);
                merlin_rng_commit_witness_bytes(&mrng,buf,sizeof(size_t),
                        (const uint8_t*) ys[i].dataBytes(), crypto_core_ed25519_SCALARBYTES);
            }
        }

        // FIXME: crypto_core_ed25519_scalar_random generates
        //     crypto_core_ed25519_SCALARBYTES random bytes, whereas 
        //     merlin_rng_finalize uses 32 bytes. As luck would have it
        //     crypto_core_ed25519_SCALARBYTES==32, but this is bad practice.
        crypto_core_ed25519_scalar_random(buf); // get some random bytes
        merlin_rng_finalize(&mrng, buf);    // finalize with these bytes

        merlin_rng_random_bytes(&mrng, buf, sizeof(buf)); // get hashed bytes
        merlin_rng_wipe(&mrng);                      // zeroize the RNG state

        // buf now contains 128 random bytes, reduce each 64-byte chunk
        // modulo the group order to get two random scalars
        std::pair<CRV25519::Scalar,CRV25519::Scalar> twoScalars;
        crypto_core_ed25519_scalar_reduce(twoScalars.first.bytes, buf);
        crypto_core_ed25519_scalar_reduce(twoScalars.second.bytes,
                            buf +crypto_core_ed25519_NONREDUCEDSCALARBYTES);
        return twoScalars;
    }    
};
} /* end of namespace MERLIN */
#endif // ifndef _MERLIN_H_

